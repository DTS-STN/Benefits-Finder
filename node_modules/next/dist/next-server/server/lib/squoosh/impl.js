"use strict";exports.__esModule=true;exports.processBuffer=processBuffer;var _codecs=require("./codecs");var _image_data=_interopRequireDefault(require("./image_data"));function _interopRequireDefault(obj){return obj&&obj.__esModule?obj:{default:obj};}async function processBuffer(buffer,operations,encoding,quality){let imageData=await decodeBuffer(buffer);for(const operation of operations){if(operation.type==='rotate'){imageData=await rotate(imageData,operation.numRotations);}else if(operation.type==='resize'){if(imageData.width&&imageData.width>operation.width){imageData=await resize(imageData,operation.width);}}}switch(encoding){case'jpeg':return encodeJpeg(imageData,{quality});case'webp':return encodeWebp(imageData,{quality});case'png':return encodePng(imageData);default:throw Error(`Unsupported encoding format`);}}async function decodeBuffer(_buffer){var _Object$entries$find;const buffer=Buffer.from(_buffer);const firstChunk=buffer.slice(0,16);const firstChunkString=Array.from(firstChunk).map(v=>String.fromCodePoint(v)).join('');const key=(_Object$entries$find=Object.entries(_codecs.codecs).find(([,{detectors}])=>detectors.some(detector=>detector.exec(firstChunkString))))==null?void 0:_Object$entries$find[0];if(!key){throw Error(`Buffer has an unsupported format`);}const d=await _codecs.codecs[key].dec();const rgba=d.decode(new Uint8Array(buffer));return rgba;}async function rotate(image,numRotations){image=_image_data.default.from(image);const m=await _codecs.preprocessors['rotate'].instantiate();return await m(image.data,image.width,image.height,{numRotations});}async function resize(image,width){image=_image_data.default.from(image);const p=_codecs.preprocessors['resize'];const m=await p.instantiate();return await m(image.data,image.width,image.height,{...p.defaultOptions,width});}async function encodeJpeg(image,{quality}){image=_image_data.default.from(image);const e=_codecs.codecs['mozjpeg'];const m=await e.enc();const r=await m.encode(image.data,image.width,image.height,{...e.defaultEncoderOptions,quality});return Buffer.from(r);}async function encodeWebp(image,{quality}){image=_image_data.default.from(image);const e=_codecs.codecs['webp'];const m=await e.enc();const r=await m.encode(image.data,image.width,image.height,{...e.defaultEncoderOptions,quality});return Buffer.from(r);}async function encodePng(image){image=_image_data.default.from(image);const e=_codecs.codecs['oxipng'];const m=await e.enc();const r=await m.encode(image.data,image.width,image.height,{...e.defaultEncoderOptions});return Buffer.from(r);}
//# sourceMappingURL=impl.js.map